import re
import subprocess
import platform
from pytubefix import YouTube, exceptions, streams
from os import path, makedirs, remove


def pyTube_folder():    #To check what the operating system is and then make a directory to storage files 
    sys = platform.system()
    home = path.expanduser('~')

    if sys == 'Darwin':  #Mac
        folder = path.join(home, 'Movies', 'PyTube')
    else:                #Windows, Linux
        folder = path.join(home, 'Videos', 'PyTube')

    makedirs(folder, exist_ok=True)

    return folder  #Users\user\Videos\PyTube

def onProgress(stream, chunk, remains):
    total = stream.filesize
    if total > 0:
        percent = (total - remains) / total * 100
    print(f'Downloading...{percent:06.2f}%', end='\r')  #Print in the same line

def sanitize_filename(name):
    # 移除 Windows 非法字元，並取代成底線
    name = re.sub(r'[<>:"/\\|?*]', '_', name)
    # 移除開頭結尾的點或空格
    name = name.strip(' .')
    # 限制長度（Windows 有路徑長度限制，但通常 1080p 標題不會爆）
    if len(name) > 200:
        name = name[:197] + "..."
    return name

def merge_files(video_path, audio_path, output_path):
    command = [
        "ffmpeg",
        "-i", video_path,
        "-i", audio_path,
        "-c:v", "copy",
        "-c:a", "aac",
        output_path
    ]
    subprocess.run(command,
                   stdout=subprocess.DEVNULL,
                   stdin=subprocess.DEVNULL
                   )#Run and Do not show messages generated by outer command
    remove(video_path)
    remove(audio_path)

    print("Merge complete.")

class YTDownloader:
    global output_filename
    global resolution_map 
    resolution_map = {'sd': '480p',            #resolution options
                      'hd': '720p',
                      'fhd': '1080p',
                      'qhd': '1440p',
                      'uhd': '2160p'
                     }

    def __init__(self, url, resolution):
        try:
            self.url = url
            self.yt = YouTube(url, on_progress_callback=onProgress)
            self.safe_title = sanitize_filename(self.yt.title)
            self.desired_resolution = resolution
            self.target_resolution = None
            self.folder = pyTube_folder

        except exceptions.PytubeFixError as e:
            print(f'\nPytube errors: {e}')

        except Exception as e:
            print(f'\nUnpredicted errors: {e}')

    def download_audio(self):
        audio = self.yt.streams.get_audio_only()
        if audio:
            print('Downloading audio file...')
            return audio.download(output_path=self.folder, 
                                filename_prefix='audio_')
        else:
            print('Error: No audio file exists')
            return None

    def download_video(self):

        progressive = self.yt.streams.filter(resolution=self.desired_resolution, 
                                             progressive=True).first()

        if progressive:
            print(f"Downloading {self.desired_resolution} (progressive)...")
            progressive.download(output_path=self.folder, filename=self.safe_title)
            print("Download complete.")
            return
        
        video = self.yt.streams.filter(resolution=self.desired_resolution, adaptive=True).first()

        if not video:
            print("No matching stream found.")
            return

        print("No progressive stream found. Using adaptive + ffmpeg merge.")
        print(f'Downloading {self.desired_resolution} video file (adaptive)')

        video_path = video.download(output_path=self.folder, filename_prefix='video_')
        audio_path = self.download_audio()

        output_path = path.join(self.folder, self.safe_title)

        merge_files(video_path, audio_path, output_path)

        return

